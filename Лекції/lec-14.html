<!DOCTYPE html>
<html>
<head>
	<title>МЗКІТ. Лекція №14 </title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="style.css">

</head>
<body>
    <div id="head">
    <div  class="paper">
      <div id="colontitle">МЗКІТ. Лекція №14</div>
      <ul class="lec-menu"> 
        <li><a href="index.html">Зміст</a></li>
        <li><a href="lec-01.html">01</a></li>
        <li><a href="lec-02.html">02</a></li>
        <li><a href="lec-03.html">03</a></li>
        <li><a href="lec-04.html">04</a></li>
        <li><a href="lec-05.html">05</a></li>
        <li><a href="lec-06.html">06</a></li>
        <li><a href="lec-07.html">07</a></li>
        <li><a href="lec-08.html">08</a></li>
        <li><a href="lec-09.html">09</a></li>
        <li><a href="lec-10.html">10</a></li>
        <li><a href="lec-11.html">11</a></li>
        <li><a href="lec-12.html">12</a></li>
        <li><a href="lec-13.html">13</a></li>
        <li><a href="lec-14.html">14</a></li>
        <li><a href="lec-15.html">15</a></li>
        <li><a href="lec-16.html">16</a></li> 
      </ul>  
    </div>
  </div>
  <div class="paper">
		<h1>Технологія асинхронного обміну даними AJAX</h1>
		

		<p>
			Пять лет назад вы были гадким утенком (с которым никто не разговаривал), если не знали XML. Восемнадцать месяцев назад в центре внимания оказался Ruby, а программисты, не знающие что с ним происходит, не были приглашены к бачку с охлажденной водой. Сегодня, если вы хотите попасть на технологическую вечеринку, нужен Ajax.
		</p>

		<p>
			Однако, Ajax – это <em>далеко</em> не чья-то прихоть, а мощный подход к созданию Web-сайтов, который не так трудно изучить, как полностью новый язык.
		</p>

		<p>
			Перед тем, как я погружусь в детали Ajax, давайте потратим пару минут на осмысление того, что же <em>делает</em> Ajax. Когда в наше время вы пишете приложение, у вас есть два основных варианта:
		</p>
		<ul class="ibm-bullet-list">
			<li>Настольные приложения</li>
			<li>Web-приложения</li>
		</ul>
		<p>
			Оба варианта знакомы; настольные приложения обычно поставляются на CD (или иногда загружаются с Web-сайта) и устанавливаются целиком на вашем компьютере. Они могут использовать Интернет для загрузки обновлений, но код, выполняющий эти приложения, размещен на вашем рабочем столе. Web-приложения (и это не удивительно) работают где-то на Web-сервере, а вы обращаетесь к этим приложениям через ваш Web-браузер.
		</p>

		<p>
			Более важным является то, что от того, где выполняется код этих приложений, зависит их поведение и способ вашего взаимодействия с ними. Настольные приложения обычно достаточно быстрые (они работают на вашем компьютере; вы не ждете интернет-подключения), имеют отличные пользовательские интерфейсы (обычно взаимодействующие с вашей операционной системой) и невероятно динамичны. Вы можете щелкать мышкой, вводить текст, пользоваться ниспадающими и всплывающими меню, перемещаться по окнам практически без каких-либо задержек.
		</p>

		<p>
			С другой стороны, Web-приложения обычно самые свежие по времени и предоставляют возможности, которые вы никогда бы не смогли иметь на вашем компьютере (вспомните Amazon.com и eBay). Однако с могуществом Web приходит ожидание – ожидание ответа от сервера, ожидание обновления экрана, ожидание ответа на запрос и генерирования новой страницы.
		</p>

		<p>
			Ясно, что все это упрощение, но вы получили общее представление. Как вы, возможно, уже подозреваете, Ajax пытается преодолеть разрыв между функциональностью и интерактивностью настольного приложения и всегда обновленным Web-приложением. Вы можете использовать динамические пользовательские интерфейсы, аналогичные имеющимся в настольном приложении, но доступные в Web-приложении.
		</p>

		<p>
			Так чего же мы ждем? Начнем рассмотрение Ajax и способов превращения ваших неуклюжих Web-интерфейсов в чувствительные Ajax-приложения.
		</p>
		<h2 id="N10075">Старая технология, новые хитрости</h2>

		<p>
			Что касается Ajax, то реальность такова, что он охватывает много технологий – для его освоения необходимо углубиться в несколько различных технологий (вот почему я разобью на независимые части первые несколько статей из этой серии). Хорошей новостью является то, что вы, возможно, уже знаете достаточно о многих из этих технологий – большинство из этих индивидуальных технологий изучаются легко (определенно не так трудно, как язык программирования полностью, например Java или Ruby).
		</p>
		<div class="dw-sidebar ibm-inset"><h2 id="N1007D">Определение Ajax</h2>

			<p>
				Между прочим, Ajax – это аббревиатура от Asynchronous JavaScript and XML (и DHTML, и т.д.). Фраза была придумана Джессе Джеймсом Гарретом из Adaptive Path (см. раздел <a href="#resources">Ресурсы</a>) и, по словам Джессе, <em>не</em> предназначалась быть аббревиатурой.
			</p>
		</div>
		<p>
			Вот основные технологии, вовлеченные в Ajax-приложения:
		</p>
		<ul class="ibm-bullet-list">
			<li>HTML используется для создания Web-форм и указания полей для использования в вашем приложении.</li>
			<li>JavaScript-код – это основной код, выполняющий Ajax-приложения и обеспечивающий взаимодействие с серверными приложениями.</li>
			<li>DHTML, или Dynamic HTML, помогает динамически обновлять формы. Вы будете использовать <code>div</code>, <code>span</code> и другие динамические HTML-элементы для разметки вашего HTML.</li>
			<li>DOM, Document Object Model (объектная модель документов), будет использоваться (через код JavaScript) для работы и со структурой вашего HTML, и (в некоторых случаях) с XML, полученным от сервера.</li>
		</ul>
		<p>
			Рассмотрим все это по отдельности и разберемся в том, что делает каждая из этих технологий. Я исследую каждую из них в следующих статьях; сейчас просто познакомимся поближе с этими компонентами и технологиями. Чем больше вы знаете о них, тем легче перейти от бессистемных знаний к освоению каждой из них (и действительно улучшить процесс разработки Web-приложений).
		</p>
		<h3 id="N1009C">Объект XMLHttpRequest</h3>

		<p>
			Первый объект, о котором вы хотите узнать, возможно, самый новый для вас; он называется <code>XMLHttpRequest</code>. Это объект JavaScript, и он создается так же просто, как показано в <a href="#code1">листинге 1</a>.
		</p>
		<h5 id="code1">Листинг 1. Создание нового объекта XMLHttpRequest</h5>
		<div class="codesection">
			<pre class="displaycode">&lt;script language="javascript" type="text/javascript"&gt;
				var xmlHttp = new XMLHttpRequest();
				&lt;/script&gt;
			</pre>
		</div>
		<p>
			Я детально расскажу об этом объекте в следующей статье, а сейчас осознайте, что это объект, который управляет всем вашим взаимодействием с сервером. Прежде чем идти дальше, остановитесь и подумайте об этом – это технология <em>JavaScript</em> в объекте <code>XMLHttpRequest</code>, который общается с сервером. Это не обычный ход работы приложения, и именно здесь заключается почти вся магия Ajax.
		</p>

		<p>
			В нормальных Web-приложениях пользователи заполняют поля форм и нажимают кнопку <em>Submit</em> (подтвердить). Затем форма передается на сервер полностью, сервер обрабатывает сценарий (обычно PHP или Java, возможно, CGI-процесс или что-то в этом роде), а потом передает назад всю новую страницу. Эта страница может быть HTML-страницей с новой формой с некоторыми заполненными данными, либо страницей подтверждения, либо, возможно, страницей с какими-то выбранными вариантами, зависящими от введенных в оригинальную форму данных. Естественно, пока сценарий или программа на сервере не обработается и не возвратится новая форма, пользователи должны ждать. Их экраны очистятся и будут перерисовываться по мере поступления новых данных от сервера. Вот где проявляется низкая интерактивность – пользователи не получают немедленной обратной реакции и определенно чувствуют себя не так, как при работе с настольными приложениями.
		</p>

		<p>
			Ajax по существу помещает технологию JavaScript и объект <code>XMLHttpRequest</code><em> между</em> вашей Web-формой и сервером. Когда пользователи заполняют формы, данные передаются в какой-то JavaScript-код, а не прямо на сервер. Вместо этого JavaScript-код собирает данные формы и передает запрос на сервер. Пока это происходит, форма на экране пользователя не мелькает, не мигает, не исчезает и не блокируется. Другими словами, код JavaScript передает запрос в фоновом режиме; пользователь даже не замечает, что происходит запрос на сервер. Более того, запрос передается асинхронно, а это означает, что ваш JavaScript-код (и пользователь) не ожидают ответа сервера. То есть, пользователи могут продолжать вводить данные, прокручивать страницу и работать с приложением.
		</p>

		<p>
			Затем сервер передает данные обратно в ваш JavaScript-код (все еще находящийся в вашей Web-форме), который решает, что делать с данными. Он может обновить поля формы "на лету", придавая свойство немедленности вашему приложению – пользователи получают новые данные без подтверждения или обновления их форм. JavaScript-код может даже получить данные, выполнить какие-либо вычисления и передать еще один запрос, и все это без вмешательства пользователя! В этом заключается мощь <code>XMLHttpRequest</code>. Он может общаться с сервером по своему желанию, а пользователь даже не догадывается о том, что происходит на самом деле. В результате мы получаем динамичность, чувствительность, высокую интерактивность настольного приложения вместе со всеми возможностями интернет.
		</p>
		<h3 id="N100C9">Добавление JavaScript-кода</h3>

		<p>
			После того, как вы разберетесь с <code>XMLHttpRequest</code>, оставшийся JavaScript-код превращается в рутинную работу. Фактически, вы будете использовать JavaScript-код для небольшого числа основных задач:
		</p>
		<ul class="ibm-bullet-list">
			<li>Получить данные формы: JavaScript-код упрощает извлечение данных из вашей HTML-формы и передает их на сервер.</li>
			<li>Изменить значения в форме: Форма обновляется тоже легко, от установки значений полей до замены изображений "на лету".</li>
			<li>Выполнить анализ HTML и XML: Вы будете использовать JavaScript-код для управления DOM (см. <a href="#dom">следующий раздел</a>) и для работы со структурой вашей HTML-формы и всеми XML-данными, возвращаемыми сервером.</li>
		</ul>
		<p>
			Для выполнения первых двух задач вы должны очень хорошо знать метод <code>getElementById()</code>, приведенный в <a href="#code2">листинге 2</a>.
		</p>
		<h5 id="code2">Листинг 2. Сбор и установка значений полей при помощи JavaScript-кода</h5>
		<div class="codesection">
			<pre class="displaycode">// Получить значение поля "phone" и записать его в переменную phone
				var phone = document.getElementById("phone").value;

				// Установить значения в форме, используя массив response
				document.getElementById("order").value = response[0];
				document.getElementById("address").value = response[1];
			</pre>
		</div>
		<p>
			Здесь нет ничего такого уж выдающегося, и это здорово! Вы должны начать понимать, что нет ничего чрезмерно сложного во всем этом. Как только вы освоите <code>XMLHttpRequest</code>, оставшаяся часть вашего Ajax-приложения будет простым JavaScript-кодом, похожим на приведенный в <a href="#code2">листинге 2</a>, смешанным с немного более умным HTML. К тому же, время от времени есть немного работы с DOM... Итак, давайте рассмотрим это.
		</p>
		<h3 id="dom">Завершение с DOM</h3>

		<p>
			И последнее, хотя и не менее важное, - это DOM, Document Object Model (объектная модель документа). Для некоторых из вас слухи о DOM могут быть немного пугающими – она не часто используется HTML-дизайнерами и даже немного не свойственна кодировщикам на JavaScript (пока вы действительно не решаете каких-либо программных задач высокого уровня). Вы можете найти широкое применение DOM в тяжеловесных программах, написанных на языках Java и C/C++; фактически, это и принесло DOM репутацию сложной и трудной для изучения.
		</p>

		<p>
			К счастью, использование DOM в технологии JavaScript является делом легким и в основном интуитивным. Сейчас мне, наверное, надо было бы рассказать вам, как использовать DOM или хотя бы привести пару примеров кода, но даже это сбило бы вас с верного пути. Дело в том, что вы можете продвинуться довольно далеко в изучении Ajax без необходимости примешивать сюда DOM, и это именно тот путь, который я хочу вам показать. Я вернусь к DOM в следующей статье, но сейчас просто знайте, что она где-то здесь. Когда вы начнете передавать XML-данные вперед и назад между вашим JavaScript-кодом и реальными изменениями HTML-формы, вы углубитесь в DOM. А пока можно эффективно работать с Ajax без DOM, так что пока отложим ее до поры до времени.
		</p>
		<div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a>
		</p>
		<h2 id="N100FE">Получение объекта Request</h2>

		<p>
			Вооруженные этим общим обзором, вы готовы к более пристальному изучению. Поскольку <code>XMLHttpRequest</code> является центральным для Ajax-приложений (и, возможно, нов для многих из вас) я начну с него. Как вы видели в <a href="#code1">листинге 1</a>, создать этот объект и использовать его должно быть просто, не правда ли? Подождите минуточку.
		</p>

		<p>
			Помните те ужасные войны браузеров, происходившие несколько лет назад, и как ничто не работало одинаково в разных браузерах? Поверите вы или нет, но те войны продолжаются до сих пор, хотя и с намного меньшим масштабом. И, сюрприз: <code>XMLHttpRequest</code> – это одна из жертв этих войн. Поэтому вы должны выполнить несколько различных действий для обеспечения возможности работы <code>XMLHttpRequest</code>. Я покажу вам как это сделать шаг за шагом.
		</p>
		<h3 id="N10114">Работа с браузерами Microsoft</h3>

		<p>
			Браузер Microsoft  Internet Explorer для обработки XML использует анализатор MSXML (ссылки на дополнительную информацию по MSXML вы можете найти в разделе <a href="#resources">Ресурсы</a>). Поэтому, когда вы пишете Ajax-приложения, которые должны работать в Internet Explorer, необходимо создать объект особым способом.
		</p>

		<p>
			Однако, это не так то и легко. На самом деле в ходу две различных версии MSXML. Версия MSXML зависит от версии технологии JavaScript, установленной в Internet Explorer, поэтому вам нужно написать код, подходящий для обеих версий. Взгляните на <a href="#code3">листинг 3</a>, в котором приведен код для создания <code>XMLHttpRequest</code> в браузерах Microsoft.
		</p>
		<h5 id="code3">Листинг 3. Создание объекта XMLHttpRequest в браузерах Microsoft</h5>
		<div class="codesection">
			<pre class="displaycode">var xmlHttp = false;
				try 
				{
					xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
				} 
				catch (e) 
				{
					try 
					{
						xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
					} 
					catch (e2) 
					{
						xmlHttp = false;
					}
				}
			</pre>
		</div>
		<p>
			Все это пока может не иметь смысла, но это нормально. Вы углубитесь в программирование на JavaScript, обработку ошибок, условную компиляцию и многое другое еще до окончания этой статьи. А пока вы должны записать в своей голове две основных строки:
		</p>

		<p>
			<code>xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");</code>
		</p>

		<p>
			и
		</p>

		<p>
			<code>xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");</code>.
		</p>

		<p>
			В двух словах, этот код пытается создать объект, используя одну версию MSXML; если это не получится, создается объект для второй версии. Изящно, да? Если ничего не сработало, переменная <code>xmlHttp</code> устанавливается в false, для того чтобы указать вашему коду, что что-то не так. В этом случае вы, возможно, работаете с браузером не от Microsoft и должны использовать другой код для выполнения работы.
		</p>
		<h3 id="N1013F">Работа с Mozilla и браузерами не от Microsoft</h3>

		<p>
			Если Internet Explorer не ваш браузер, либо вы пишете код для браузеров не от Microsoft, вам нужен другой код. Фактически, это простая строка, которую вы видели в <a href="#code1">листинге 1</a>:
		</p>

		<p>
			<code>var xmlHttp = new XMLHttpRequest object;</code>.
		</p>

		<p>
			Эта намного более простая строка создает объект <code>XMLHttpRequest</code> в Mozilla, Firefox, Safari, Opera и в большой степени в каждом браузере не от Microsoft, поддерживающем Ajax в любой форме или разновидности.
		</p>
		<h3 id="N10152">Объединение</h3>

		<p>
			Мы хотим поддерживать <em>все</em> браузеры. Кто хочет писать приложение, работающее только в Internet Explorer, или приложение, работающее только во всех остальных браузерах? Еще хуже, хотите ли вы написать ваше приложение дважды? Конечно, нет! Итак, объединим поддержку для Internet Explorer и для остальных браузеров. В <a href="#code4">листинге 4</a> приведен код, делающий это.
		</p>
		<h5 id="code4">Листинг 4. Создание объекта XMLHttpRequest для всех браузеров</h5>
		<div class="codesection">
			<pre class="displaycode">/* Создание нового объекта XMLHttpRequest для общения с Web-сервером */
				var xmlHttp = false;
				/*@cc_on @*/
				/*@if (@_jscript_version &gt;= 5)
				try 
				{
					xmlHttp = new ActiveXObject("Msxml2.XMLHTTP");
				} 
				catch (e) 
				{
					try 
					{
						xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
					} 
					catch (e2) 
					{
						xmlHttp = false;
					}
				}
				@end @*/

				if (!xmlHttp &amp;&amp; typeof XMLHttpRequest != 'undefined') {
				xmlHttp = new XMLHttpRequest();
			}
		</pre>
	</div>
	<p>
		Пока проигнорируйте комментарии и непонятные теги, типа <code>@cc_on</code>; это специальные команды JavaScript-компилятора, которые мы рассмотрим детально в моей следующей статье, которая будет полностью посвящена <code>XMLHttpRequest</code>. Основу этого кода можно разделить на три шага:
	</p>
	<ol>
		<li>Создайте переменную <code>xmlHttp</code> для ссылки на объект <code>XMLHttpRequest</code>, который вы создадите.</li>
		<li>В блоке try создайте объект в браузерах Microsoft:

			<ul class="ibm-bullet-list">
				<li>В блоке try создайте объект с использованием объекта <code>Msxml2.XMLHTTP</code>.</li>
				<li>Если это не получится, В блоке try создайте объект с использованием объекта <code>Microsoft.XMLHTTP</code>.</li>
			</ul></li>
			<li>Если <code>xmlHttp</code> все еще не установлен, создайте объект для остальных браузеров.</li></ol>
			<p>
				В конце этого процесса <code>xmlHttp</code> должен ссылаться на корректный объект <code>XMLHttpRequest</code>, независимо от используемого пользователем браузера.
			</p>
			<h3 id="N10192">Пара слов о защите</h3>

			<p>
				Как насчет защиты? Современные браузеры предлагают пользователям возможность повысить уровень безопасности, отключить технологию JavaScript и запретить множество настроек в своих браузерах. В этих ситуациях ваш код, вероятно, не будет работать ни при каких обстоятельствах. Для таких ситуаций вы должны элегантно решить проблемы – есть, по крайней мере, одна статья об этом, а одну я напишу позднее (это, наверное, будет длинная серия, но не беспокойтесь – вы все освоите до окончания этой серии статей). Пока же вы пишете устойчивый, но не совершенный код, который отлично подходит для изучения Ajax. Вы вернетесь к более качественному коду позже.
			</p>
			<div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a>
			</p>
			<h2 id="N10198">Запрос/ответ в мире Ajax</h2>

			<p>
				Итак, вы уже знакомы с Ajax и имеете базовое представление об объекте <code>XMLHttpRequest</code>  и о том, как создать его. Если вы читали внимательно, то вы даже понимаете, что это технология JavaScript общается с любым Web-приложением на сервере, а не ваша HTML-форма, которую вы подтвердили напрямую.
			</p>

			<p>
				Что мы пропустили? Как на самом деле использовать <code>XMLHttpRequest</code>. Поскольку это критический код, который вы будете использовать в некоторых формах в <em>каждом</em> вашем Ajax-приложении, рассмотрим коротко, как выглядит базовая модель запрос/ответ в Ajax.
			</p>
			<h3 id="N101AA">Выполнение запроса</h3>

			<p>
				У вас есть ваш превосходный новый объект <code>XMLHttpRequest</code>; приведем его в движение. Во-первых, нам понадобится JavaScript-метод, который ваша Web-страница может вызвать (например, когда пользователь вводит текст или выбирает вариант из меню). Затем, нужно следовать одной и той же основной схеме практически во всех ваших Ajax-приложениях:
			</p>
			<ol>
				<li>Получить какие-либо данные из Web-формы.</li>
				<li>Создать URL для подключения.</li>
				<li>Открыть соединение с сервером.</li>
				<li>Установить функцию для сервера, которая выполнится после его ответа.</li>
				<li>Передать запрос.</li></ol>
				<p>
					В <a href="#code5">листинге 5</a> приведен пример Ajax-метода, который выполняет именно эти операции и именно в этом порядке:
				</p>
				<h5 id="code5">Листинг 5. Выполнить запрос с Ajax</h5>
				<div class="codesection">
					<pre class="displaycode">function callServer() {
						// Получить city и state из web-формы
						var city = document.getElementById("city").value;
						var state = document.getElementById("state").value;
						// Продолжать только если есть значения обоих полей
						if ((city == null) || (city == "")) return;
						if ((state == null) || (state == "")) return;

						// Создать URL для подключения
						var url = "/scripts/getZipCode.php?city=" + escape(city) + "&amp;state=" + escape(state);

						// Открыть соединение с сервером
						xmlHttp.open("GET", url, true);

						// Установить функцию для сервера, которая выполнится после его ответа
						xmlHttp.onreadystatechange = updatePage;

						// SПередать запрос
						xmlHttp.send(null);
					}
				</pre>
			</div>
			<p>
				Многое из этого не требует пояснений. Первая часть кода использует базовый JavaScript-код для сбора значений из нескольких полей формы. Затем код устанавливает PHP-сценарий в качестве URL для подключения. Обратите внимание, как указывать URL и как добавлять к нему city и state (из формы), используя простые GET-параметры.
			</p>

			<p>
				Затем открывается соединение; это первое место, где вы опять увидели в действии <code>XMLHttpRequest</code>. Указывается метод соединения (GET) и URL. Последний параметр, когда установлен в <code>true</code>, запрашивает асинхронное соединение (то есть, делает это способом, сооветствующим названию Ajax). При использовании <code>false</code> код ждал бы выполнения запроса и не продолжал бы работу до получения ответа. При использовании <code>true</code> ваши пользователи могут работать с формой (и даже вызывать другие JavaScript-методы) пока сервер обрабатывает этот запрос в фоновом режиме.
			</p>

			<p>
				Свойство <code>onreadystatechange xmlHttp</code> (вспоминайте, это ваш экземпляр объекта <code>XMLHttpRequest</code>) позволяет вам информировать сервер о том, что следует делать после завершения работы (что может быть через пять минут или через пять часов). Поскольку код не собирается ждать сервер, вы должны дать серверу знать, что делать, так чтобы вы смогли среагировать. В данном случае будет инициирован конкретный метод (называемый <code>updatePage()</code>) после завершения сервером обработки вашего запроса.
			</p>

			<p>
				Наконец, вызывается <code>send()</code> со значением <code>null</code>. Поскольку вы добавили данные для передачи на сервер (city и state) в URL запроса, вам не надо передавать что-либо в запросе. Таким образом, передается ваш запрос, и сервер может делать то, что вы указали ему делать.
			</p>

			<p>
				Если вы кроме этого ничего больше не делаете, обратите внимание на то, насколько все просто и понятно! В отличие от осознания вами асинхронной природы Ajax, все это действительно простые вещи. Вы оцените то, как это освобождает вас для концентрации внимания на крутых приложениях и интерфейсах, а не на сложном HTTP-коде запроса/ответа.
			</p>

			<p>
				Код в <a href="#code5">листинге 5</a> очень прост. Данные являются простым текстом и могут быть включены как часть URL-запроса. GET посылает запрос вместо более сложного POST. Не добавляется XML, заголовки контента, не передаются данные в теле запроса – можно сказать, Ajax-утопия.
			</p>

			<p>
				Не переживайте - ситуация станет более сложной по мере выпуска статей 
				этой серии. Вы научитесь передавать POST-запросы, устанавливать заголовки запроса и типы содержимого, кодировать XML в вашем сообщении, добавлять защиту в ваш запрос – список довольно большой! Не беспокойтесь пока о сложных вещах; узнайте основы и вскоре вы освоите полный арсенал Ajax-средств.

			</p>
			<h3 id="N101F9">Обработка ответа</h3>

			<p>
				Теперь вы должны разобраться с ответом сервера. Пока вы должны знать только два момента:
			</p>
			<ul class="ibm-bullet-list">
				<li>Не делать ничего, пока свойство <code>xmlHttp.readyState</code> не будет равно 4.</li>
				<li>Сервер будет записывать свой ответ в свойстве <code>xmlHttp.responseText</code>.</li>
			</ul>
			<p>
				Первый момент (состояния готовности) готовится стать основным объемом следующей статьи; вы узнаете о стадиях HTTP-запроса столько, сколько никогда даже и не хотели знать. Пока вы просто проверяйте на равенство определенному значению (4), и все будет работать (и вы будете знать, что искать в следующей статье). Второй момент (использование свойства <code>xmlHttp.responseText</code> для получения ответа от сервера) является простым. В <a href="#code6">листинге 6</a> приведен пример метода (который сервер может вызвать), основанного на значениях, переданных в <a href="#code5">листинге 5</a>.
			</p>
			<h5 id="code6">Листинг 6. Обработка ответа от сервера</h5>
			<div class="codesection">
				<pre class="displaycode">function updatePage() 
					{
						if (xmlHttp.readyState == 4) 
						{
							var response = xmlHttp.responseText;
							document.getElementById("zipCode").value = response;
						}
					}
				</pre>
			</div>
			<p>
				Опять же, код не является трудным или сложным. Он ожидает, пока сервер не вызовет его с нужным состоянием готовности, и затем использует значение, которое сервер возвращает (в данном случае ZIP-код для введенного пользователем города и штата), для установки другого поля формы. В результате поле <code>zipCode</code> неожиданно появляется с ZIP-кодом, но пользователь <em>ни разу не щелкнул по кнопке</em>! Это поведение настольного приложения, о чем я говорил ранее. Оперативность, ощущение динамичности и т.д., а все с маленьким Ajax-кодом.
			</p>

			<p>
				Наблюдательные читатели, возможно, заметят, что поле <code>zipCode</code> является обычным текстовым полем. После возврата сервером ZIP-кода и установки этого поля методом <code>updatePage()</code> в значение ZIP-кода города/штата пользователи <em>могут</em> переопределить это значение. Так сделано умышленно по двум причинам: сохранить этот пример простым и показать вам, что иногда нужно, чтобы пользователи имели возможность переопределить значения, возвращенные сервером. Помните об обоих моментах; они важны при хорошем дизайне пользовательского интерфейса.
			</p>
			<div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a>
			</p>
			<h2 id="N10232">Перехват в Web-формах </h2>

			<p>
				Что нам осталось? В сущности, не много. Вы имеете JavaScript-метод, собирающий введенную пользователем в форму информацию, передаете ее серверу, предоставляете еще один JavaScript-метод для обработки ответа и даже устанавливаете значение поля, когда этот ответ приходит. Все что осталось на самом деле – <em>вызвать</em> этот первый метод и запустить полный процесс. Вы могли бы, очевидно, добавить кнопку в вашу HTML-форму, но это же старый, добрый 2001 год, не так ли? Воспользуемся возможностями технологии JavaScript, как показано в <a href="#code7">листинге 7</a>.
			</p>
			<h5 id="code7">Листинг 7. Запуск Ajax-процесса</h5>
			<div class="codesection">
				<pre class="displaycode">&lt;form&gt;
					&lt;p&gt;City: &lt;input type="text" name="city" id="city" size="25" 
					<strong>onChange="callServer();"</strong> /&gt;&lt;/p&gt;
					&lt;p&gt;State: &lt;input type="text" name="state" id="state" size="25" 
					<strong>onChange="callServer();"</strong> /&gt;&lt;/p&gt;
					&lt;p&gt;Zip Code: &lt;input type="text" name="zipCode" id="zipCode" size="5" /&gt;&lt;/p&gt;
					&lt;/form&gt;
				</pre>
			</div>
			<p>
				Если это выглядит как еще один кусок в рутинном, в некоторой степени, коде – вы правы, так и есть! Когда пользователь вводит новое значение для любого из полей city или state, запускается метод <code>callServer()</code>, и Ajax-функция начинается. Вам кажется, что вы начинаете понимать суть вещей? Отлично!
			</p>
			<div class="ibm-alternate-rule"><hr></div><p class="ibm-ind-link ibm-back-to-top"><a href="#ibm-pcon" class="ibm-anchor-up-link">В начало</a>
			</p>
			<h2 id="N10253">В заключение</h2>

			<p>
				В настоящий момент вы, возможно, не готовы взять и написать ваше первое Ajax-приложение, по крайней мере, пока не исследовали раздел <a href="#resources">Ресурсы</a>. Однако, вы уже можете начать понимать основную идею о том, как работают такие приложения и что такое объект <code>XMLHttpRequest</code>. В готовящихся статьях вы изучите этот объект, а также то, как контролировать взаимодействие JavaScript-to-server и работать с HTML-формами, и даже разберетесь с DOM.
			</p>

			<p>
				Пока же потратьте некоторое время на размышления о том, насколько мощными могут быть Ajax-приложения. Представьте себе Web-форму, которая реагирует не только тогда, когда вы нажимаете кнопку, но и когда вы вводите данные в поле, когда выбираете вариант из списка вариантов и даже когда перемещаете курсор по экрану. Подумайте о том, что на самом деле означает слово <em>асинхронный</em>. Подумайте о JavaScript-коде, выполняющемся и <em>не ожидающем</em>, пока сервер возвратит ответы на его запросы. С какими проблемами вы можете столкнуться?  С какими вещами следует проявлять осторожность? И как дизайн ваших форм изменится, принимая во внимание этот новый подход в программировании?
			</p>

			<p>
				Потратив некоторое время на эти моменты, вы получите больше пользы, чем просто при получении какого-либо кода, который можно скопировать и поместить в приложение, не понимая его на самом деле. В следующей статье вы примените эти идеи на практике; я приведу подробную информацию о коде, который вам нужен для работы аналогичных приложений. А до этого наслаждайтесь возможностями Ajax.
			</p>



			<h2>Контрольні запитання</h2>

			<ol>


				<li> </li>

			</ol>
		</div>
	</body>
	</html>